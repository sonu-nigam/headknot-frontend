{"version":3,"sources":["../src/index.ts","../src/atomWithFn.ts","../src/createAtomProvider.tsx","../src/useHydrateStore.ts","../src/createAtomStore.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './atomWithFn';\nexport * from './createAtomProvider';\nexport * from './createAtomStore';\nexport * from './useHydrateStore';\n","import { atom } from 'jotai';\n\nimport type { WritableAtom } from 'jotai/vanilla';\n\ntype WrapFn<T> = T extends (...args: infer _A) => infer _R ? { __fn: T } : T;\n\nconst wrapFn = <T>(fnOrValue: T): WrapFn<T> =>\n  (typeof fnOrValue === 'function' ? { __fn: fnOrValue } : fnOrValue) as any;\n\ntype UnwrapFn<T> = T extends { __fn: infer U } ? U : T;\n\nconst unwrapFn = <T>(wrappedFnOrValue: T): UnwrapFn<T> =>\n  (wrappedFnOrValue &&\n  typeof wrappedFnOrValue === 'object' &&\n  '__fn' in wrappedFnOrValue\n    ? wrappedFnOrValue.__fn\n    : wrappedFnOrValue) as any;\n\n/**\n * Jotai atoms don't allow functions as values by default. This function is a\n * drop-in replacement for `atom` that wraps functions in an object while\n * leaving non-functions unchanged. The wrapper object should be completely\n * invisible to consumers of the atom.\n */\nexport const atomWithFn = <T>(initialValue: T): WritableAtom<T, [T], void> => {\n  const baseAtom = atom(wrapFn(initialValue));\n\n  return atom(\n    (get) => unwrapFn(get(baseAtom)) as T,\n    (_get, set, value) => set(baseAtom, wrapFn(value))\n  );\n};\n","'use client';\n\nimport React, { PropsWithChildren } from 'react';\nimport { createStore } from 'jotai/vanilla';\n\nimport { JotaiStore, SimpleWritableAtomRecord } from './createAtomStore';\nimport { useHydrateStore, useSyncStore } from './useHydrateStore';\n\nconst getFullyQualifiedScope = (storeName: string, scope: string) => {\n  return `${storeName}:${scope}`;\n};\n\n/**\n * Context mapping store name and scope to store. The 'provider' scope is used\n * to reference any provider belonging to the store, regardless of scope.\n */\nconst PROVIDER_SCOPE = 'provider';\nconst AtomStoreContext = React.createContext<Map<string, JotaiStore>>(\n  new Map()\n);\n\n/**\n * Tries to find a store in each of the following places, in order:\n * 1. The store context, matching the store name and scope\n * 2. The store context, matching the store name and 'provider' scope\n * 3. Otherwise, return undefined\n */\nexport const useAtomStore = (\n  storeName: string,\n  scope: string = PROVIDER_SCOPE,\n  warnIfUndefined: boolean = true\n): JotaiStore | undefined => {\n  const storeContext = React.useContext(AtomStoreContext);\n  const store =\n    storeContext.get(getFullyQualifiedScope(storeName, scope)) ??\n    storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));\n\n  if (!store && warnIfUndefined) {\n    console.warn(\n      `Tried to access jotai store '${storeName}' outside of a matching provider.`\n    );\n  }\n\n  return store;\n};\n\nexport type ProviderProps<T extends object> = Partial<T> &\n  PropsWithChildren<{\n    store?: JotaiStore;\n    scope?: string;\n    initialValues?: Partial<T>;\n    resetKey?: any;\n  }>;\n\nexport const HydrateAtoms = <T extends object>({\n  initialValues,\n  children,\n  store,\n  atoms,\n  ...props\n}: Omit<ProviderProps<T>, 'scope'> & {\n  atoms: SimpleWritableAtomRecord<T>;\n}) => {\n  useHydrateStore(atoms, { ...initialValues, ...props } as any, {\n    store,\n  });\n  useSyncStore(atoms, props as any, {\n    store,\n  });\n\n  return <>{children}</>;\n};\n\n/**\n * Creates a generic provider for a jotai store.\n * - `initialValues`: Initial values for the store.\n * - `props`: Dynamic values for the store.\n */\nexport const createAtomProvider = <T extends object, N extends string = ''>(\n  storeScope: N,\n  atoms: SimpleWritableAtomRecord<T>,\n  options: { effect?: React.FC } = {}\n) => {\n  const Effect = options.effect;\n\n  // eslint-disable-next-line react/display-name\n  return ({ store, scope, children, resetKey, ...props }: ProviderProps<T>) => {\n    const [storeState, setStoreState] =\n      React.useState<JotaiStore>(createStore());\n\n    React.useEffect(() => {\n      if (resetKey) {\n        setStoreState(createStore());\n      }\n    }, [resetKey]);\n\n    const previousStoreContext = React.useContext(AtomStoreContext);\n\n    const storeContext = React.useMemo(() => {\n      const newStoreContext = new Map(previousStoreContext);\n\n      if (scope) {\n        // Make the store findable by its fully qualified scope\n        newStoreContext.set(\n          getFullyQualifiedScope(storeScope, scope),\n          storeState\n        );\n      }\n\n      // Make the store findable by its store name alone\n      newStoreContext.set(\n        getFullyQualifiedScope(storeScope, PROVIDER_SCOPE),\n        storeState\n      );\n\n      return newStoreContext;\n    }, [previousStoreContext, scope, storeState]);\n\n    return (\n      <AtomStoreContext.Provider value={storeContext}>\n        <HydrateAtoms store={storeState} atoms={atoms} {...(props as any)}>\n          {!!Effect && <Effect />}\n\n          {children}\n        </HydrateAtoms>\n      </AtomStoreContext.Provider>\n    );\n  };\n};\n","import React from 'react';\nimport { useSetAtom } from 'jotai';\nimport { useHydrateAtoms } from 'jotai/utils';\n\nimport {\n  SimpleWritableAtomRecord,\n  UseHydrateAtoms,\n  UseSyncAtoms,\n} from './createAtomStore';\n\n/**\n * Hydrate atoms with initial values for SSR.\n */\nexport const useHydrateStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  initialValues: Parameters<UseHydrateAtoms<any>>[0],\n  options: Parameters<UseHydrateAtoms<any>>[1] = {}\n) => {\n  const values: any[] = [];\n\n  for (const key of Object.keys(atoms)) {\n    const initialValue = initialValues[key];\n\n    if (initialValue !== undefined) {\n      values.push([atoms[key], initialValue]);\n    }\n  }\n\n  useHydrateAtoms(values, options);\n};\n\n/**\n * Update atoms with new values on changes.\n */\nexport const useSyncStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  values: any,\n  { store }: Parameters<UseSyncAtoms<any>>[1] = {}\n) => {\n  for (const key of Object.keys(atoms)) {\n    const value = values[key];\n    const atom = atoms[key];\n\n    // eslint-disable-next-line react-compiler/react-compiler\n    const set = useSetAtom(atom, { store });\n\n    // eslint-disable-next-line react-compiler/react-compiler\n    React.useEffect(() => {\n      if (value !== undefined && value !== null) {\n        set(value);\n      }\n    }, [set, value]);\n  }\n};\n","import React, { useMemo } from 'react';\nimport { getDefaultStore, useAtom, useAtomValue, useSetAtom } from 'jotai';\nimport { selectAtom, useHydrateAtoms } from 'jotai/utils';\n\nimport { atomWithFn } from './atomWithFn';\nimport { createAtomProvider, useAtomStore } from './createAtomProvider';\n\nimport type { ProviderProps } from './createAtomProvider';\nimport type { Atom, createStore, WritableAtom } from 'jotai/vanilla';\n\nexport type JotaiStore = ReturnType<typeof createStore>;\n\nexport type UseAtomOptions = {\n  scope?: string;\n  store?: JotaiStore;\n  delay?: number;\n  warnIfNoStore?: boolean;\n};\n\ntype UseAtomOptionsOrScope = UseAtomOptions | string;\n\ntype StoreAtomsWithoutExtend<T> = {\n  [K in keyof T]: T[K] extends Atom<any> ? T[K] : SimpleWritableAtom<T[K]>;\n};\n\ntype ValueTypesForAtoms<T> = {\n  [K in keyof T]: T[K] extends Atom<infer V> ? V : never;\n};\n\ntype StoreInitialValues<T> = ValueTypesForAtoms<StoreAtomsWithoutExtend<T>>;\n\ntype StoreAtoms<T, E> = StoreAtomsWithoutExtend<T> & E;\n\nexport type SimpleWritableAtom<T> = WritableAtom<T, [T], void>;\n\nexport type SimpleWritableAtomRecord<T> = {\n  [K in keyof T]: SimpleWritableAtom<T[K]>;\n};\n\nexport type AtomRecord<O> = {\n  [K in keyof O]: Atom<O[K]>;\n};\n\ntype UseNameStore<N extends string = ''> = `use${Capitalize<N>}Store`;\ntype NameStore<N extends string = ''> = N extends '' ? 'store' : `${N}Store`;\ntype NameProvider<N extends string = ''> = `${Capitalize<N>}Provider`;\n\ntype UseKeyValue<K extends string = ''> = `use${Capitalize<K>}Value`;\ntype GetKey<K extends string = ''> = `get${Capitalize<K>}`;\ntype UseSetKey<K extends string = ''> = `useSet${Capitalize<K>}`;\ntype SetKey<K extends string = ''> = `set${Capitalize<K>}`;\ntype UseKeyState<K extends string = ''> = `use${Capitalize<K>}State`;\ntype SubscribeKey<K extends string = ''> = `subscribe${Capitalize<K>}`;\n\nexport type UseHydrateAtoms<T> = (\n  initialValues: Partial<Record<keyof T, any>>,\n  options?: Parameters<typeof useHydrateAtoms>[1]\n) => void;\nexport type UseSyncAtoms<T> = (\n  values: Partial<Record<keyof T, any>>,\n  options?: {\n    store?: JotaiStore;\n  }\n) => void;\n\nexport type StoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  atom: StoreAtoms<T, E>;\n  name: N;\n};\n\ntype GetAtomFn = <V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => V;\n\ntype UseAtomValueFn = <V, S = V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope,\n  selector?: (v: V, prevSelectorOutput?: S) => S,\n  equalityFnOrDeps?:\n    | ((prevSelectorOutput: S, selectorOutput: S) => boolean)\n    | unknown[],\n  deps?: unknown[]\n) => S;\n\ntype SetAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => (...args: A) => R;\n\ntype UseSetAtomFn = SetAtomFn;\n\ntype UseAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => [V, (...args: A) => R];\n\ntype SubscribeAtomFn = <V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => (callback: (newValue: V) => void) => () => void;\n\ntype UseValueOptions<V, S> = {\n  selector?: (v: V, prevSelectorOutput?: S) => S;\n  equalityFn?: (prev: S, next: S) => boolean;\n} & UseAtomOptions;\n\n// store.use<Key>Value()\nexport type UseKeyValueApis<O> = {\n  [K in keyof O as UseKeyValue<K & string>]: {\n    (): O[K] extends Atom<infer V> ? V : never;\n    <S>(\n      selector: O[K] extends Atom<infer V>\n        ? (v: V, prevSelectorOutput?: S) => S\n        : never,\n      deps?: unknown[]\n    ): S;\n    <S>(\n      selector:\n        | (O[K] extends Atom<infer V>\n            ? (v: V, prevSelectorOutput?: S) => S\n            : never)\n        | undefined,\n      equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n      deps?: unknown[]\n    ): S;\n  };\n};\n\n// store.get<Key>()\nexport type GetKeyApis<O> = {\n  [K in keyof O as GetKey<K & string>]: O[K] extends Atom<infer V>\n    ? () => V\n    : never;\n};\n\n// store.useSet<Key>()\nexport type UseSetKeyApis<O> = {\n  [K in keyof O as UseSetKey<K & string>]: O[K] extends WritableAtom<\n    infer _V,\n    infer A,\n    infer R\n  >\n    ? () => (...args: A) => R\n    : never;\n};\n\n// store.set<Key>(...args)\nexport type SetKeyApis<O> = {\n  [K in keyof O as SetKey<K & string>]: O[K] extends WritableAtom<\n    infer _V,\n    infer A,\n    infer R\n  >\n    ? (...args: A) => R\n    : never;\n};\n\n// store.use<Key>State()\nexport type UseKeyStateApis<O> = {\n  [K in keyof O as UseKeyState<K & string>]: O[K] extends WritableAtom<\n    infer V,\n    infer A,\n    infer R\n  >\n    ? () => [V, (...args: A) => R]\n    : never;\n};\n\n// store.subscribe<Key>(callback)\nexport type SubscribeKeyApis<O> = {\n  [K in keyof O as SubscribeKey<K & string>]: O[K] extends Atom<infer V>\n    ? (callback: (newValue: V) => void) => () => void\n    : never;\n};\n\n// store.useValue('key')\nexport type UseParamKeyValueApi<O> = {\n  // abc\n  <K extends keyof O>(key: K): O[K] extends Atom<infer V> ? V : never;\n  <K extends keyof O, S>(\n    key: K,\n    selector: O[K] extends Atom<infer V>\n      ? (v: V, prevSelectorOutput?: S) => S\n      : never,\n    deps?: unknown[]\n  ): S;\n  <K extends keyof O, S>(\n    key: K,\n    selector:\n      | (O[K] extends Atom<infer V>\n          ? (v: V, prevSelectorOutput?: S) => S\n          : never)\n      | undefined,\n    equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n    deps?: unknown[]\n  ): S;\n};\n\n// store.get('key')\nexport type GetParamKeyApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends Atom<infer V> ? V : never;\n\n// store.useSet('key')\nexport type UseSetParamKeyApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends WritableAtom<infer _V, infer A, infer R>\n  ? (...args: A) => R\n  : never;\n// store.set('key', ...args)\nexport type SetParamKeyApi<O> = <K extends keyof O, A extends unknown[]>(\n  key: K,\n  ...args: A\n) => O[K] extends WritableAtom<infer _V, A, infer R> ? R : never;\n\n// store.useState('key')\nexport type UseParamKeyStateApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends WritableAtom<infer V, infer A, infer R>\n  ? [V, (...args: A) => R]\n  : never;\n\n// store.subscribe('key', callback)\nexport type SubscribeParamKeyApi<O> = <K extends keyof O, V>(\n  key: K,\n  callback: (newValue: V) => void\n) => O[K] extends Atom<V> ? () => void : never;\n\nexport type UseAtomParamValueApi = {\n  <V>(atom: Atom<V>): V;\n  <V, S = V>(\n    atom: Atom<V>,\n    selector: (v: V, prevSelectorOutput?: S) => S,\n    deps?: unknown[]\n  ): S;\n  <V, S = V>(\n    atom: Atom<V>,\n    selector: ((v: V, prevSelectorOutput?: S) => S) | undefined,\n    equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n    deps?: unknown[]\n  ): S;\n};\nexport type GetAtomParamApi = <V>(atom: Atom<V>) => V;\nexport type UseSetAtomParamApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => (...args: A) => R;\nexport type SetAtomParamApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => (...args: A) => R;\nexport type UseAtomParamStateApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => [V, (...args: A) => R];\nexport type SubscribeAtomParamApi = <V>(\n  atom: Atom<V>\n) => (callback: (newValue: V) => void) => () => void;\n\nexport type ReturnOfUseStoreApi<T, E> = UseKeyValueApis<StoreAtoms<T, E>> &\n  GetKeyApis<StoreAtoms<T, E>> &\n  UseSetKeyApis<StoreAtoms<T, E>> &\n  SetKeyApis<StoreAtoms<T, E>> &\n  UseKeyStateApis<StoreAtoms<T, E>> &\n  SubscribeKeyApis<StoreAtoms<T, E>> & {\n    /**\n     * When providing `selector`, the atom value will be transformed using the selector function.\n     * The selector and equalityFn MUST be memoized.\n     *\n     * @see https://jotai.org/docs/utilities/select#selectatom\n     *\n     * @example\n     *   const store = useStore()\n     *   // only rerenders when the first element of the array changes\n     *   const arrayFirst = store.useValue('array', array => array[0], [])\n     *   // only rerenders when the first element of the array changes, but returns the whole array\n     *   const array = store.useValue('array', undefined, (prev, next) => prev[0] === next[0], [])\n     *   // without dependency array, then you need to memoize the selector and equalityFn yourself\n     *   const cb = useCallback((array) => array[n], [n])\n     *   const arrayNth = store.useValue('array', cb)\n     *\n     * @param key The key of the atom\n     * @param selector A function that takes the atom value and returns the value to be used. Defaults to identity function that returns the atom value.\n     * @param equalityFnOrDeps Dependency array or a function that compares the previous selector output and the new selector output. Defaults to comparing outputs of the selector function.\n     * @param deps Dependency array for the selector and equalityFn\n     */\n    useValue: UseParamKeyValueApi<StoreAtoms<T, E>>;\n    get: GetParamKeyApi<StoreAtoms<T, E>>;\n    useSet: UseSetParamKeyApi<StoreAtoms<T, E>>;\n    set: SetParamKeyApi<StoreAtoms<T, E>>;\n    useState: UseParamKeyStateApi<StoreAtoms<T, E>>;\n    subscribe: SubscribeParamKeyApi<StoreAtoms<T, E>>;\n    /**\n     * When providing `selector`, the atom value will be transformed using the selector function.\n     * The selector and equalityFn MUST be memoized.\n     *\n     * @see https://jotai.org/docs/utilities/select#selectatom\n     *\n     * @example\n     *   const store = useStore()\n     *   // only rerenders when the first element of the array changes\n     *   const arrayFirst = store.useAtomValue(arrayAtom, array => array[0])\n     *   // only rerenders when the first element of the array changes, but returns the whole array\n     *   const array = store.useAtomValue(arrayAtom, undefined, (prev, next) => prev[0] === next[0])\n     *   // without dependency array, then you need to memoize the selector and equalityFn yourself\n     *  const cb = useCallback((array) => array[n], [n])\n     * const arrayNth = store.useAtomValue(arrayAtom, cb)\n     *\n     * @param atom The atom to use\n     * @param selector A function that takes the atom value and returns the value to be used. Defaults to identity function that returns the atom value.\n     * @param equalityFn Dependency array or a function that compares the previous selector output and the new selector output. Defaults to comparing outputs of the selector function.\n     * @param deps Dependency array for the selector and equalityFn\n     */\n    useAtomValue: UseAtomParamValueApi;\n    getAtom: GetAtomParamApi;\n    useSetAtom: UseSetAtomParamApi;\n    setAtom: SetAtomParamApi;\n    useAtomState: UseAtomParamStateApi;\n    subscribeAtom: SubscribeAtomParamApi;\n    store: JotaiStore | undefined;\n  };\n\ntype UseKeyStateUtil<T, E> = <K extends keyof StoreAtoms<T, E>>(\n  key: K,\n  options?: UseAtomOptionsOrScope\n) => StoreAtoms<T, E>[K] extends WritableAtom<infer V, infer A, infer R>\n  ? [V, (...args: A) => R]\n  : never;\n\ntype UseKeyValueUtil<T, E> = <\n  K extends keyof StoreAtoms<T, E>,\n  S = StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n>(\n  key: K,\n  options?: UseValueOptions<\n    StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n    S\n  >,\n  deps?: unknown[]\n) => S;\n\ntype UseKeySetUtil<T, E> = <K extends keyof StoreAtoms<T, E>>(\n  key: K,\n  options?: UseAtomOptionsOrScope\n) => StoreAtoms<T, E>[K] extends WritableAtom<infer _V, infer A, infer R>\n  ? (...args: A) => R\n  : never;\n\nexport type AtomStoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  name: N;\n} & {\n  [key in keyof Record<NameProvider<N>, object>]: React.FC<\n    ProviderProps<StoreInitialValues<T>>\n  >;\n} & {\n  [key in keyof Record<NameStore<N>, object>]: StoreApi<T, E, N>;\n} & {\n  [key in keyof Record<UseNameStore<N>, object>]: UseStoreApi<T, E>;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}State`, object>]: UseKeyStateUtil<\n    T,\n    E\n  >;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}Value`, object>]: UseKeyValueUtil<\n    T,\n    E\n  >;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}Set`, object>]: UseKeySetUtil<T, E>;\n};\n\nexport type UseStoreApi<T, E> = (\n  options?: UseAtomOptionsOrScope\n) => ReturnOfUseStoreApi<T, E>;\n\nconst capitalizeFirstLetter = (str = '') =>\n  str.length > 0 ? str[0].toUpperCase() + str.slice(1) : '';\n\nconst isAtom = (possibleAtom: unknown): boolean =>\n  !!possibleAtom &&\n  typeof possibleAtom === 'object' &&\n  'read' in possibleAtom &&\n  typeof possibleAtom.read === 'function';\n\nconst convertScopeShorthand = (\n  optionsOrScope: UseAtomOptionsOrScope = {}\n): UseAtomOptions =>\n  typeof optionsOrScope === 'string'\n    ? { scope: optionsOrScope }\n    : optionsOrScope;\n\nconst useConvertScopeShorthand: typeof convertScopeShorthand = (\n  optionsOrScope\n) => {\n  const convertedOptions = convertScopeShorthand(optionsOrScope);\n  // Works because all values are primitives\n  // eslint-disable-next-line react-compiler/react-compiler\n  return useMemo(() => convertedOptions, Object.values(convertedOptions));\n};\n\nconst identity = (x: any) => x;\n\nexport interface CreateAtomStoreOptions<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string,\n> {\n  name: N;\n  delay?: UseAtomOptions['delay'];\n  effect?: React.FC;\n  extend?: (atomsWithoutExtend: StoreAtomsWithoutExtend<T>) => E;\n  suppressWarnings?: boolean;\n}\n\n/**\n * Create an atom store from an initial value.\n * Each property will have a getter and setter.\n *\n * @example\n * const { exampleStore, useExampleStore, useExampleValue, useExampleState, useExampleSet } = createAtomStore({ count: 1, say: 'hello' }, { name: 'example' as const })\n * const [count, setCount] = useExampleState()\n * const say = useExampleValue('say')\n * const setSay = useExampleSet('say')\n * setSay('world')\n * const countAtom = exampleStore.atom.count\n */\nexport const createAtomStore = <\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n>(\n  initialState: T,\n  {\n    name,\n    delay: delayRoot,\n    effect,\n    extend,\n    suppressWarnings,\n  }: CreateAtomStoreOptions<T, E, N>\n): AtomStoreApi<T, E, N> => {\n  const atomsWithoutExtend: Record<string, Atom<unknown>> = {};\n  const writableAtomsWithoutExtend: Record<string, Atom<unknown>> = {};\n  const atomIsWritable: Record<string, boolean> = {};\n\n  /**\n   * Constructor to generate the object returned by `useStoreApi`. Using\n   * prototypes is much faster than constructing a new object every time the\n   * hook is called.\n   */\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  function UseStoreApiFactory(\n    this: {\n      options: UseAtomOptions;\n      store: JotaiStore | undefined;\n    },\n    options: UseAtomOptions,\n    store: JotaiStore | undefined\n  ) {\n    this.options = options;\n    this.store = store;\n  }\n\n  for (const [key, atomOrValue] of Object.entries(initialState)) {\n    const atomConfig: Atom<unknown> = isAtom(atomOrValue)\n      ? atomOrValue\n      : atomWithFn(atomOrValue);\n\n    atomsWithoutExtend[key] = atomConfig;\n\n    const writable = 'write' in atomConfig;\n    atomIsWritable[key] = writable;\n\n    if (writable) {\n      writableAtomsWithoutExtend[key] = atomConfig;\n    }\n  }\n\n  const atoms: Record<string, Atom<unknown>> = { ...atomsWithoutExtend };\n\n  if (extend) {\n    const extendedAtoms = extend(atomsWithoutExtend as any);\n\n    for (const [key, atomConfig] of Object.entries(extendedAtoms)) {\n      atoms[key] = atomConfig;\n      atomIsWritable[key] = 'write' in atomConfig;\n    }\n  }\n\n  const useStore = (optionsOrScope: UseAtomOptionsOrScope = {}) => {\n    const {\n      scope,\n      store,\n      warnIfNoStore = !suppressWarnings,\n    } = convertScopeShorthand(optionsOrScope);\n    const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);\n    return store ?? contextStore;\n  };\n\n  const useAtomValueWithStore: UseAtomValueFn = (\n    atomConfig,\n    store,\n    optionsOrScope,\n    selector = identity,\n    equalityFnOrDeps,\n    deps\n  ) => {\n    const options = convertScopeShorthand(optionsOrScope);\n    const equalityFn =\n      typeof equalityFnOrDeps === 'function' ? equalityFnOrDeps : undefined;\n    deps = (typeof equalityFnOrDeps === 'function'\n      ? deps\n      : equalityFnOrDeps) ?? [selector, equalityFn];\n\n    const [memoizedSelector, memoizedEqualityFn] = React.useMemo(\n      () => [selector, equalityFn],\n      // eslint-disable-next-line react-compiler/react-compiler\n      deps\n    );\n\n    const selectorAtom = selectAtom(\n      atomConfig,\n      memoizedSelector,\n      memoizedEqualityFn\n    ) as Atom<any>;\n    return useAtomValue(selectorAtom, {\n      store,\n      delay: options.delay ?? delayRoot,\n    });\n  };\n\n  const getAtomWithStore: GetAtomFn = (atomConfig, store, _optionsOrScope) => {\n    return (store ?? getDefaultStore()).get(atomConfig);\n  };\n\n  const useSetAtomWithStore: SetAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return useSetAtom(atomConfig, { store });\n  };\n\n  const setAtomWithStore: UseSetAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return (...args) =>\n      (store ?? (getDefaultStore() as NonNullable<typeof store>)).set(\n        atomConfig,\n        ...args\n      );\n  };\n\n  const useAtomStateWithStore: UseAtomFn = (\n    atomConfig,\n    store,\n    optionsOrScope\n  ) => {\n    const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);\n    return useAtom(atomConfig, { store, delay });\n  };\n\n  const subscribeAtomWithStore: SubscribeAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return (callback) => {\n      store ??= getDefaultStore();\n      const unsubscribe = store.sub(atomConfig, () => {\n        callback(store!.get(atomConfig));\n      });\n      return () => unsubscribe();\n    };\n  };\n\n  for (const key of Object.keys(atoms)) {\n    const atomConfig = atoms[key];\n    const isWritable = atomIsWritable[key];\n    const capitalizedKey = capitalizeFirstLetter(key);\n\n    UseStoreApiFactory.prototype[`use${capitalizedKey}Value`] = function (\n      selector?: (v: any, prevSelectorOutput?: any) => any,\n      equalityFnOrDeps?:\n        | ((prevSelectorOutput: any, selectorOutput: any) => boolean)\n        | unknown[],\n      deps?: unknown[]\n    ) {\n      return useAtomValueWithStore(\n        atomConfig,\n        this.store,\n        this.options,\n        selector,\n        equalityFnOrDeps,\n        deps\n      );\n    };\n\n    UseStoreApiFactory.prototype[`get${capitalizedKey}`] = function () {\n      return getAtomWithStore(atomConfig, this.store, this.options);\n    };\n\n    UseStoreApiFactory.prototype[`subscribe${capitalizedKey}`] = function (\n      callback: (newValue: any) => void\n    ) {\n      return subscribeAtomWithStore(\n        atomConfig,\n        this.store,\n        this.options\n      )(callback);\n    };\n\n    if (isWritable) {\n      UseStoreApiFactory.prototype[`useSet${capitalizedKey}`] = function () {\n        return useSetAtomWithStore(atomConfig as any, this.store, this.options);\n      };\n\n      UseStoreApiFactory.prototype[`set${capitalizedKey}`] = function (\n        ...args: any[]\n      ) {\n        return setAtomWithStore(\n          atomConfig as any,\n          this.store,\n          this.options\n        )(...args);\n      };\n\n      UseStoreApiFactory.prototype[`use${capitalizedKey}State`] = function () {\n        return useAtomStateWithStore(\n          atomConfig as any,\n          this.store,\n          this.options\n        );\n      };\n    }\n  }\n\n  const defineUseStoreApiMethod = (\n    methodNameWithKey: string,\n    methodNameWithAtomConfig: string,\n    fnWithKey: (\n      atomConfig: any,\n      store: JotaiStore | undefined,\n      options: UseAtomOptions,\n      ...args: any[]\n    ) => any,\n    fnWithAtomConfig = fnWithKey\n  ) => {\n    UseStoreApiFactory.prototype[methodNameWithKey] = function (\n      key: string,\n      ...args: any[]\n    ) {\n      const atomConfig = atoms[key] as any;\n      return fnWithKey(atomConfig, this.store, this.options, ...args);\n    };\n\n    UseStoreApiFactory.prototype[methodNameWithAtomConfig] = function (\n      atomConfig: any,\n      ...args: any[]\n    ) {\n      return fnWithAtomConfig(atomConfig, this.store, this.options, ...args);\n    };\n  };\n\n  defineUseStoreApiMethod('useValue', 'useAtomValue', useAtomValueWithStore);\n  defineUseStoreApiMethod('get', 'getAtom', getAtomWithStore);\n  defineUseStoreApiMethod('useSet', 'useSetAtom', useSetAtomWithStore);\n  defineUseStoreApiMethod(\n    'set',\n    'setAtom',\n    (atomConfig, store, options, ...args) =>\n      setAtomWithStore(atomConfig, store, options)(...args),\n    setAtomWithStore\n  );\n  defineUseStoreApiMethod('useState', 'useAtomState', useAtomStateWithStore);\n  defineUseStoreApiMethod(\n    'subscribe',\n    'subscribeAtom',\n    (atomConfig, store, options, callback) =>\n      subscribeAtomWithStore(atomConfig, store, options)(callback),\n    subscribeAtomWithStore\n  );\n\n  const Provider = createAtomProvider(name, writableAtomsWithoutExtend as any, {\n    effect,\n  });\n\n  const storeApi: StoreApi<T, E, N> = {\n    atom: atoms as any,\n    name,\n  };\n\n  const useStoreApi: UseStoreApi<T, E> = (options = {}) => {\n    const convertedOptions = useConvertScopeShorthand(options);\n    const store = useStore(convertedOptions);\n\n    return useMemo(\n      () => new (UseStoreApiFactory as any)(convertedOptions, store),\n      [store, convertedOptions]\n    );\n  };\n\n  const useNameState = <K extends keyof StoreAtoms<T, E>>(\n    key: K,\n    options?: UseAtomOptionsOrScope\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useAtomStateWithStore(atoms[key as string] as any, store, options);\n  };\n\n  const useNameValue = <\n    K extends keyof StoreAtoms<T, E>,\n    S = StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n  >(\n    key: K,\n    {\n      equalityFn,\n      selector,\n      ...options\n    }: UseValueOptions<\n      StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n      S\n    > = {},\n    deps?: unknown[]\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useAtomValueWithStore(\n      atoms[key as string],\n      store,\n      options,\n      selector as any,\n      equalityFn ?? deps,\n      equalityFn && deps\n    );\n  };\n\n  const useNameSet = <K extends keyof StoreAtoms<T, E>>(\n    key: K,\n    options?: UseAtomOptionsOrScope\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useSetAtomWithStore(atoms[key as string] as any, store, options);\n  };\n\n  const capitalizedName = capitalizeFirstLetter(name);\n  const storeApiIndex = name.length === 0 ? 'store' : `${name}Store`;\n\n  return {\n    [`${capitalizedName}Provider`]: Provider,\n    [storeApiIndex]: storeApi,\n    [`use${capitalizedName}Store`]: useStoreApi,\n    [`use${capitalizedName}State`]: useNameState,\n    [`use${capitalizedName}Value`]: useNameValue,\n    [`use${capitalizedName}Set`]: useNameSet,\n    name,\n  } as any;\n};\n\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n): StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? (v: V, prevSelectorOutput?: S) => S\n    : never,\n  deps?: unknown[]\n): S;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? ((v: V, prevSelectorOutput?: S) => S) | undefined\n    : never,\n  equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n  deps?: unknown[]\n): S;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector?: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? (v: V, prevSelectorOutput?: S) => S\n    : never,\n  equalityFnOrDeps?: any,\n  deps?: unknown[]\n) {\n  return store.useValue(key, selector, equalityFnOrDeps, deps);\n}\n\nexport function useAtomStoreSet<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n) {\n  return store.useSet(key);\n}\n\nexport function useAtomStoreState<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n) {\n  return store.useState(key);\n}\n\nexport function useStoreAtomValue<T, E, V>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>\n): V;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector: (v: V, prevSelectorOutput?: S) => S,\n  deps?: unknown[]\n): S;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector: ((v: V, prevSelectorOutput?: S) => S) | undefined,\n  equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n  deps?: unknown[]\n): S;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector?: (v: V, prevSelectorOutput?: S) => S,\n  equalityFnOrDeps?: any,\n  deps?: unknown[]\n) {\n  return store.useAtomValue(atom, selector, equalityFnOrDeps, deps);\n}\n\nexport function useStoreSetAtom<T, E, V, A extends unknown[], R>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: WritableAtom<V, A, R>\n) {\n  return store.useSetAtom(atom);\n}\n\nexport function useStoreAtomState<T, E, V, A extends unknown[], R>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: WritableAtom<V, A, R>\n) {\n  return store.useAtomState(atom);\n}\n"],"mappings":"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","names":["import_react","import_jotai","atom","React","React","import_react","import_jotai","import_utils","React","_a","atom"]}